/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

int *_ltl2ba_pointer_signal2_status  =    (int *)0;
int *_ltl2ba_pointer_signal1_status  =    (int *)0;
int _ltl2ba_active_red2  =    0;
int _ltl2ba_atomic_red2  =    1;
int _ltl2ba_active_red1  =    0;
int _ltl2ba_atomic_red1  =    1;
void __CPROVER_atomic_end(void) ;
void __CPROVER_atomic_begin(void) ;
int _ltl2ba_state_var  =    0;
int _ltl2ba_sym_to_id(void) ;
void _ltl2ba_transition(void) ;
void _ltl2ba_result(void) ;
#line 60 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 36 "/usr/include/bits/semaphore.h"
union __anonunion_sem_t_31 {
   char __size[32] ;
   long __align ;
};
#line 36 "/usr/include/bits/semaphore.h"
typedef union __anonunion_sem_t_31 sem_t;
#line 234 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 243
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 251
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 35 "/usr/include/semaphore.h"
extern  __attribute__((__nothrow__)) int sem_init(sem_t *__sem , int __pshared , unsigned int __value ) ;
#line 53
extern int sem_wait(sem_t *__sem ) ;
#line 68
extern  __attribute__((__nothrow__)) int sem_post(sem_t *__sem ) ;
#line 447 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 365 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 11 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
sem_t sem1  ;
#line 11 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
sem_t sem2  ;
#line 13 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
int isRed1(int s ) 
{ 


  {
#line 14
  return (s == 2);
}
}
#line 17 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
int isRed2(int s ) 
{ 


  {
#line 18
  return (s == 2);
}
}
#line 21 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
void *signal1(void *d ) 
{ 
  int status ;

  {
#line 22
  status = 0;
  {
#line 24
  __CPROVER_atomic_begin();
#line 24
  _ltl2ba_pointer_signal1_status = & status;
#line 24
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 24
  _ltl2ba_active_red1 = (_Bool)1;
#line 24
  _ltl2ba_transition();
#line 24
  __CPROVER_atomic_end();
  b1: 
#line 24
  printf((char const   */* __restrict  */)"1 -> GREEN\n");
#line 25
  sleep(2U);
#line 26
  __CPROVER_atomic_begin();
#line 26
  status = 1;
#line 26
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 26
  _ltl2ba_transition();
#line 26
  __CPROVER_atomic_end();
#line 27
  printf((char const   */* __restrict  */)"1 -> ORANGE\n");
#line 28
  sleep(1U);
#line 29
  __CPROVER_atomic_begin();
#line 29
  status = 2;
#line 29
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 29
  _ltl2ba_transition();
#line 29
  __CPROVER_atomic_end();
#line 30
  printf((char const   */* __restrict  */)"1 -> RED\n");
#line 31
  sem_post(& sem1);
#line 33
  sem_wait(& sem2);
#line 34
  __CPROVER_atomic_begin();
#line 34
  status = 0;
#line 34
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 34
  _ltl2ba_transition();
#line 34
  __CPROVER_atomic_end();
#line 35
  printf((char const   */* __restrict  */)"1 -> GREEN\n");
#line 36
  sleep(2U);
#line 37
  __CPROVER_atomic_begin();
#line 37
  status = 1;
#line 37
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 37
  _ltl2ba_transition();
#line 37
  __CPROVER_atomic_end();
#line 38
  printf((char const   */* __restrict  */)"1 -> ORANGE\n");
#line 39
  sleep(1U);
#line 40
  __CPROVER_atomic_begin();
#line 40
  status = 2;
#line 40
  _ltl2ba_atomic_red1 = isRed1(*_ltl2ba_pointer_signal1_status);
#line 40
  _ltl2ba_transition();
#line 40
  __CPROVER_atomic_end();
#line 41
  printf((char const   */* __restrict  */)"1 -> RED\n");
#line 42
  sem_post(& sem1);
  }
  {
#line 55
  __CPROVER_atomic_begin();
#line 55
  _ltl2ba_atomic_red1 = (_Bool)1;
#line 55
  _ltl2ba_active_red1 = (_Bool)0;
#line 55
  _ltl2ba_transition();
#line 55
  __CPROVER_atomic_end();
  e1: 
#line 55
  pthread_exit((void *)0);
  }
}
}
#line 58 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
void *signal2(void *d ) 
{ 
  int status ;

  {
#line 59
  status = 2;
  {
#line 62
  __CPROVER_atomic_begin();
#line 62
  _ltl2ba_pointer_signal2_status = & status;
#line 62
  _ltl2ba_atomic_red2 = isRed2(*_ltl2ba_pointer_signal2_status);
#line 62
  _ltl2ba_active_red2 = (_Bool)1;
#line 62
  _ltl2ba_transition();
#line 62
  __CPROVER_atomic_end();
  b2: 
#line 62
  sem_wait(& sem1);
#line 63
  __CPROVER_atomic_begin();
#line 63
  status = 0;
#line 63
  _ltl2ba_atomic_red2 = isRed2(*_ltl2ba_pointer_signal2_status);
#line 63
  _ltl2ba_transition();
#line 63
  __CPROVER_atomic_end();
#line 64
  printf((char const   */* __restrict  */)"2 -> GREEN\n");
#line 65
  sleep(2U);
#line 66
  __CPROVER_atomic_begin();
#line 66
  status = 1;
#line 66
  _ltl2ba_atomic_red2 = isRed2(*_ltl2ba_pointer_signal2_status);
#line 66
  _ltl2ba_transition();
#line 66
  __CPROVER_atomic_end();
#line 67
  printf((char const   */* __restrict  */)"2 -> ORANGE\n");
#line 68
  sleep(1U);
#line 69
  __CPROVER_atomic_begin();
#line 69
  status = 2;
#line 69
  _ltl2ba_atomic_red2 = isRed2(*_ltl2ba_pointer_signal2_status);
#line 69
  _ltl2ba_transition();
#line 69
  __CPROVER_atomic_end();
#line 70
  printf((char const   */* __restrict  */)"2 -> RED\n");
#line 71
  sem_post(& sem2);
  }
  {
#line 85
  __CPROVER_atomic_begin();
#line 85
  _ltl2ba_atomic_red2 = (_Bool)1;
#line 85
  _ltl2ba_active_red2 = (_Bool)0;
#line 85
  _ltl2ba_transition();
#line 85
  __CPROVER_atomic_end();
  e2: 
#line 85
  pthread_exit((void *)0);
  }
}
}
#line 88 "/home/nephe/Documents/Research/dev/baProduct/test/crossing_exclusive_semaphore/crossing_exclusive_semaphore.c"
int main(void) 
{ 
  pthread_t t1 ;
  pthread_t t2 ;

  {
#line 91
  printf((char const   */* __restrict  */)"Start\n");
#line 93
  sem_init(& sem1, 0, 0U);
#line 94
  sem_init(& sem2, 0, 0U);
#line 96
  printf((char const   */* __restrict  */)"Create\n");
#line 97
  pthread_create((pthread_t */* __restrict  */)(& t1), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & signal1, (void */* __restrict  */)((void *)0));
#line 98
  pthread_create((pthread_t */* __restrict  */)(& t2), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & signal2, (void */* __restrict  */)((void *)0));
#line 99
  printf((char const   */* __restrict  */)"Join\n");
#line 101
  pthread_join(t1, (void **)((void *)0));
#line 102
  pthread_join(t2, (void **)((void *)0));
#line 104
  printf((char const   */* __restrict  */)"End\n");
  {
  __CPROVER_atomic_begin();
  _ltl2ba_result();
  __CPROVER_atomic_end();
#line 106
  return (0);
  }
}
}
void _ltl2ba_transition() {
  int choice = nondet_uint(); 
  switch (_ltl2ba_state_var) {
  case 0:
    if (choice == 0) {
      __CPROVER_assume(!_ltl2ba_atomic_red1 && !_ltl2ba_atomic_red2);
      _ltl2ba_state_var = 1;
    } else if (choice == 1) {
       __CPROVER_assume(1);
       _ltl2ba_state_var = 0;
    } else {
       __CPROVER_assume(0);
    }
    break;
  case 1:
    __CPROVER_assert(0, "ERROR_SURE");
    break;
  }
}

int _ltl2ba_surely_reject[2] = {0, 0};

int _ltl2ba_surely_accept[2] = {0, 1};

int _ltl2ba_stutter_accept[8] = {
   1, 1,
   0, 1,
   0, 1,
   0, 1,
};

int _ltl2ba_sym_to_id() {
   int id = 0;
   id |= (_ltl2ba_atomic_red2 << 1);
   id |= (_ltl2ba_atomic_red1 << 0);
   return id; 
}

void _ltl2ba_result() {
   int reject_sure = _ltl2ba_surely_accept[_ltl2ba_state_var];
   __CPROVER_assert(!reject_sure, "ERROR SURE");
   
   int id = _ltl2ba_sym_to_id();
   int accept_stutter =_ltl2ba_stutter_accept[id * 2 + _ltl2ba_state_var];
   __CPROVER_assert(!accept_stutter, "ERROR MAYBE");
   int valid_sure = _ltl2ba_surely_reject[_ltl2ba_state_var];
   __CPROVER_assert(valid_sure, "VALID MAYBE");
   
   }


