/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

int *_ltl2ba_pointer_nprod  =    (int *)0;
int _ltl2ba_active_p2  =    0;
int _ltl2ba_atomic_p2  =    0;
int _ltl2ba_active_p1  =    0;
int _ltl2ba_atomic_p1  =    0;
void __CPROVER_atomic_end(void) ;
void __CPROVER_atomic_begin(void) ;
int _ltl2ba_state_var  =    0;
int _ltl2ba_sym_to_id(void) ;
void _ltl2ba_transition(void) ;
void _ltl2ba_result(void) ;
#line 60 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_3 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_3 pthread_mutex_t;
#line 234 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 243
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 763
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 774
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 4 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
int nprod  ;
#line 5 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
pthread_mutex_t m  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 7 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
int fp1(int nprod___0 ) 
{ 


  {
#line 8
  return (nprod___0 < 0);
}
}
#line 11 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
void *prod(void *d ) 
{ 


  {
  pb: 
  {
#line 13
  pthread_mutex_lock(& m);
#line 14
  __CPROVER_atomic_begin();
#line 14
  nprod ++;
#line 14
  if (_ltl2ba_active_p1) {
#line 14
    _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 14
  if (_ltl2ba_active_p2) {
#line 14
    _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 14
  _ltl2ba_transition();
#line 14
  __CPROVER_atomic_end();
#line 15
  pthread_mutex_unlock(& m);
#line 16
  pthread_mutex_lock(& m);
#line 17
  __CPROVER_atomic_begin();
#line 17
  nprod ++;
#line 17
  if (_ltl2ba_active_p1) {
#line 17
    _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 17
  if (_ltl2ba_active_p2) {
#line 17
    _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 17
  _ltl2ba_transition();
#line 17
  __CPROVER_atomic_end();
#line 18
  pthread_mutex_unlock(& m);
#line 19
  pthread_mutex_lock(& m);
#line 20
  __CPROVER_atomic_begin();
#line 20
  nprod ++;
#line 20
  if (_ltl2ba_active_p1) {
#line 20
    _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 20
  if (_ltl2ba_active_p2) {
#line 20
    _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 20
  _ltl2ba_transition();
#line 20
  __CPROVER_atomic_end();
#line 21
  pthread_mutex_unlock(& m);
#line 22
  pthread_mutex_lock(& m);
#line 23
  __CPROVER_atomic_begin();
#line 23
  nprod ++;
#line 23
  if (_ltl2ba_active_p1) {
#line 23
    _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 23
  if (_ltl2ba_active_p2) {
#line 23
    _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 23
  _ltl2ba_transition();
#line 23
  __CPROVER_atomic_end();
#line 24
  pthread_mutex_unlock(& m);
#line 25
  pthread_mutex_lock(& m);
#line 26
  __CPROVER_atomic_begin();
#line 26
  nprod ++;
#line 26
  if (_ltl2ba_active_p1) {
#line 26
    _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 26
  if (_ltl2ba_active_p2) {
#line 26
    _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
  }
#line 26
  _ltl2ba_transition();
#line 26
  __CPROVER_atomic_end();
#line 27
  pthread_mutex_unlock(& m);
  }
  pe: 
#line 29
  pthread_exit((void *)0);
}
}
#line 32 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
void *cons1(void *d ) 
{ 


  {
  {
#line 34
  __CPROVER_atomic_begin();
#line 34
  _ltl2ba_pointer_nprod = & nprod;
#line 34
  _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
#line 34
  _ltl2ba_active_p1 = (_Bool)1;
#line 34
  _ltl2ba_transition();
#line 34
  __CPROVER_atomic_end();
  c1b: 
#line 34
  while (1) {
#line 36
    pthread_mutex_lock(& m);
#line 37
    if (nprod >= 1) {
      {
#line 38
      __CPROVER_atomic_begin();
#line 38
      nprod --;
#line 38
      _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
#line 38
      if (_ltl2ba_active_p2) {
#line 38
        _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
      }
#line 38
      _ltl2ba_transition();
#line 38
      __CPROVER_atomic_end();
      }
    }
#line 39
    pthread_mutex_unlock(& m);
  }
  }
  {
#line 42
  __CPROVER_atomic_begin();
#line 42
  _ltl2ba_atomic_p1 = (_Bool)0;
#line 42
  _ltl2ba_active_p1 = (_Bool)0;
#line 42
  _ltl2ba_transition();
#line 42
  __CPROVER_atomic_end();
  c1e: 
#line 42
  pthread_exit((void *)0);
  }
}
}
#line 45 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
void *cons2(void *d ) 
{ 


  {
  {
#line 47
  __CPROVER_atomic_begin();
#line 47
  _ltl2ba_pointer_nprod = & nprod;
#line 47
  _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
#line 47
  _ltl2ba_active_p2 = (_Bool)1;
#line 47
  _ltl2ba_transition();
#line 47
  __CPROVER_atomic_end();
  c2b: 
#line 47
  while (1) {
#line 49
    pthread_mutex_lock(& m);
#line 50
    if (nprod >= 1) {
      {
#line 51
      __CPROVER_atomic_begin();
#line 51
      nprod --;
#line 51
      _ltl2ba_atomic_p2 = fp1(*_ltl2ba_pointer_nprod);
#line 51
      if (_ltl2ba_active_p1) {
#line 51
        _ltl2ba_atomic_p1 = fp1(*_ltl2ba_pointer_nprod);
      }
#line 51
      _ltl2ba_transition();
#line 51
      __CPROVER_atomic_end();
      }
    }
#line 52
    pthread_mutex_unlock(& m);
  }
  }
  {
#line 55
  __CPROVER_atomic_begin();
#line 55
  _ltl2ba_atomic_p2 = (_Bool)0;
#line 55
  _ltl2ba_active_p2 = (_Bool)0;
#line 55
  _ltl2ba_transition();
#line 55
  __CPROVER_atomic_end();
  c2e: 
#line 55
  pthread_exit((void *)0);
  }
}
}
#line 58 "/home/nephe/Documents/Research/dev/baProduct/test/prod_cons_mutex/prod_cons_mutex.c"
int main(int argc , char **argv ) 
{ 
  pthread_t t1 ;
  pthread_t t2 ;
  pthread_t t3 ;

  {
#line 61
  pthread_create((pthread_t */* __restrict  */)(& t1), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & prod, (void */* __restrict  */)((void *)0));
#line 62
  pthread_create((pthread_t */* __restrict  */)(& t2), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & cons1, (void */* __restrict  */)((void *)0));
#line 63
  pthread_create((pthread_t */* __restrict  */)(& t3), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 & cons2, (void */* __restrict  */)((void *)0));
  {
  __CPROVER_atomic_begin();
  _ltl2ba_result();
  __CPROVER_atomic_end();
#line 64
  return (0);
  }
}
}
void _ltl2ba_transition() {
  int choice = nondet_uint(); 
  switch (_ltl2ba_state_var) {
  case 0:
    if (choice == 0) {
      __CPROVER_assume(_ltl2ba_atomic_p2);
      _ltl2ba_state_var = 1;
    } else if (choice == 1) {
       __CPROVER_assume(_ltl2ba_atomic_p1);
       _ltl2ba_state_var = 1;
    } else if (choice == 2) {
       __CPROVER_assume(1);
       _ltl2ba_state_var = 0;
    } else {
       __CPROVER_assume(0);
    }
    break;
  case 1:
    __CPROVER_assert(0, "ERROR_SURE");
    break;
  }
}

int _ltl2ba_surely_reject[2] = {0, 0};

int _ltl2ba_surely_accept[2] = {0, 1};

int _ltl2ba_stutter_accept[8] = {
   0, 1,
   1, 1,
   1, 1,
   1, 1,
};

int _ltl2ba_sym_to_id() {
   int id = 0;
   id |= (_ltl2ba_atomic_p2 << 1);
   id |= (_ltl2ba_atomic_p1 << 0);
   return id; 
}

void _ltl2ba_result() {
   int reject_sure = _ltl2ba_surely_accept[_ltl2ba_state_var];
   __CPROVER_assert(!reject_sure, "ERROR SURE");
   
   int id = _ltl2ba_sym_to_id();
   int accept_stutter =_ltl2ba_stutter_accept[id * 2 + _ltl2ba_state_var];
   __CPROVER_assert(!accept_stutter, "ERROR MAYBE");
   int valid_sure = _ltl2ba_surely_reject[_ltl2ba_state_var];
   __CPROVER_assert(valid_sure, "VALID MAYBE");
   
   }


